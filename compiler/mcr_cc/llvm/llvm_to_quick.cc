/**
 * Calling Quick code (that is code generated by the default/optimizing Android
 * backend) from LLVM.
 * Ideally we want to import ALL of the quick code in LLVM, as this transition
 * is not optimized.
 *
 * Copyright (C) 2021  Paschalis Mpeis (paschalis.mpeis-AT-gmail.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
#include "function_helper.h"

#include "hgraph_to_llvm-inl.h"
#include "hgraph_to_llvm.h"

#include "llvm_macros_irb.h"

using namespace ::llvm;
namespace art {
namespace LLVM {

/**
 * INFO LtQ_StackBug we need to perform a slightly larger alloca to
 *      solve an issue that occured in some cases.
 */
Value* FunctionHelper::LLVMtoQuick(
    HGraphToLLVM* HL, IRBuilder* irb, HInvoke* hinvoke,
    Value* art_method_or_idx,
    Value* receiver, bool is_static, std::vector<Value*> callee_args,
    DataType::Type ret_type, uint32_t didx, const char* shorty,
    uint32_t shorty_len, std::string pretty_method, std::string call_info) {

  bool has_uses = hinvoke->HasUses();
  UNUSED(has_uses);

  D2LOG(INFO) << __func__ << ": " << pretty_method << ":"
    << shorty << ":" << (is_static ? "STATIC" : "");

  const bool isInterface = hinvoke->IsInvokeInterface();
  const bool isVirtual = hinvoke->IsInvokeVirtual();
  if(isInterface || isVirtual) {
    std::stringstream ss;
    ss << "WARNING: Invoke" << (isInterface?"Interface":"Virtual");
    LOGLLVMD(ERROR, ss.str());
  }

  if (!is_static) {
    receiver->setName("receiver");
  }

  // removes return type
  size_t num_slots = shorty_len - 1;

  // +1 in case of receiver.
  for (size_t i = 1; i < shorty_len; ++i) {
    char c = shorty[i];
    // wide values take 2x slot
    if (c == 'J' || c == 'D') {
      num_slots++;
    }
  }

  // extra slot for receiver
  if (!is_static) num_slots++;

  // LtQ_Workaround2 for LtQ_StackBug
  num_slots+=2;

  // Allocate an array (place at the first basic block)
  Type* argsArrayTy = ArrayType::get(irb->getJIntTy(), num_slots);
  Value* lnum_slots = irb->getJInt(num_slots);
  AllocaInst* invoke_args = new AllocaInst(
      argsArrayTy, 0, lnum_slots, Align(), "invoke_args",
      irb->GetInsertBlock());

  Value* invoke_args_ptr = irb->CreateBitCast(
      invoke_args, irb->getJIntTy()->getPointerTo());
  invoke_args_ptr->setName("invoke_args_ptr"); 

  uint32_t arg_offset = 0;
  if (!is_static) {
    HL->StoreToObjectOffset(invoke_args_ptr, arg_offset, receiver);
    arg_offset += 4;
  }

  for (size_t i = 1; i < shorty_len; ++i) {
    Value* arg = callee_args.at(i-1);
    arg = irb->UpcastInt(arg, DataType::FromShorty(shorty[i]));
    HL->StoreToObjectOffset(invoke_args_ptr, arg_offset, arg);
    switch (shorty[i]) {
      case 'Z':
      case 'B':
      case 'C':
      case 'S':
      case 'I':
      case 'F':
      case 'L':
        arg_offset += 4;
        break;
      case 'D':
      case 'J':
        arg_offset += 8;
        break;
    }
  }

  // Allocate for storing the result (in JValue union)
  AllocaInst* jvalue = new AllocaInst(
      irb->getJValueTy(), 0, "jvalue", irb->GetInsertBlock());

  if (McrDebug::VerifyInvokeQuickLlvmToQuick()) {
    irb->AndroidLogPrint(WARNING, "-> Quick:" + call_info + ": " + pretty_method);
  }

#ifdef ART_MCR_ANDROID_10
  // Push quick frame
  StructType* managed_stack_type = irb->GetManagedStackTy();
  AllocaInst* managed_stack = irb->CreateAlloca(managed_stack_type);
  managed_stack->setName("ManagedStack");
  HL->ArtCallPushQuickFrame(managed_stack);

  if(McrDebug::DebugLlvmCode3()) {
    irb->AndroidLogPrintHex(WARNING, "Alloca: ManagedStack", managed_stack);
    irb->AndroidLogPrint(ERROR, "===== LL2 LtQ: PushQuickFrame ========");
    HL->ArtCallVerifyStackFrameCurrent();
    irb->AndroidLogPrint(ERROR, "=================================");
  }

  Value* lshorty = irb->mCreateGlobalStringPtr(shorty);
  Value* largs_size=irb->getJInt(arg_offset);

  constexpr bool use_wrapper = false;
  HL->ArtCallInvokeQuick__(hinvoke, art_method_or_idx, invoke_args_ptr,
      largs_size, jvalue, lshorty, is_static, use_wrapper);
#elif defined(ART_MCR_ANDROID_6)
  // Parameters
  std::vector<Value*> args;
  args.push_back(art_method_or_idx);
  args.push_back(invoke_args_ptr);
  // args size is same as final offset
  args.push_back(irb->getJInt(arg_offset));
  args.push_back(jvalue);
  irb->CreateCall(fh->__InvokeWrapper(), args);
#endif

  Value* result = nullptr;
  if (ret_type != DataType::Type::kVoid) {
    result = irb->CallGetReturnValue(HL, jvalue, ret_type);
    result->setName("result");
  }
  if (McrDebug::VerifyInvokeQuickLlvmToQuick()) {
    irb->AndroidLogPrint(WARNING, "<- Quick:" + call_info + ": "
        + pretty_method + "\n");
  }

  // Pop quick frame
  HL->ArtCallPopQuickFrame(managed_stack);

  if(McrDebug::DebugLlvmCode3()) {
    irb->AndroidLogPrint(ERROR, "===== LL3 LtQ: PopQuickFrame ========");
    HL->ArtCallVerifyStackFrameCurrent();
    irb->AndroidLogPrint(ERROR, "=================================");
  }

  return result;
}

#include "llvm_macros_undef.h"

}  // namespace LLVM
}  // namespace art
