/**
 * Several debug flags for LLVM controlled by files to enable them
 * dynamically on compilations without requiring a recomplation of the backend/libart-compiler
 *
 * Those files can be generated by some bash scripts or a helper application.
 *
 * Copyright (C) 2021  Paschalis Mpeis (paschalis.mpeis-AT-gmail.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
#include "debug.h"
#include "mcr_rt/mcr_rt.h"
#include "mcr_cc/analyser.h"

#include <android-base/logging.h>
#include "base/os.h"

using namespace ::android::base;

namespace art {

bool McrDebug::debug_llvm_code_ = false;
bool McrDebug::debug_invoke_jni_ = false;
bool McrDebug::debug_invoke_quick_ = false;

bool McrDebug::opt_quick_through_rt_ = false;
bool McrDebug::sc_simplify_= false;
bool McrDebug::skip_suspend_check_ = false;

bool McrDebug::verify_art_method_ = false;
bool McrDebug::verify_art_obj_ = false;
bool McrDebug::verify_art_class_ = false;

bool McrDebug::verify_invoke_ = false;
bool McrDebug::verify_invoke_jni_ = false;
bool McrDebug::verify_invoke_quick_ = false;
bool McrDebug::verify_invoke_quick_ThroughRTslow_ = false;
bool McrDebug::verify_invoke_quick_LlvmToQuick_ = false;
bool McrDebug::verify_invoke_llvm_ = false;
bool McrDebug::verify_llvm_called_ = false;
bool McrDebug::verify_llvm_invoke_wrapper = false;

bool McrDebug::verify_load_class_ = false;
bool McrDebug::verify_speculation_ = false;
bool McrDebug::verify_speculation_miss_ = false;
bool McrDebug::speculative_devirt_ = true;
bool McrDebug::interpret_nonhot_ = false;

bool McrDebug::die_on_speculation_miss_ = false;
bool McrDebug::verify_init_inner_ = false;
bool McrDebug::verify_basic_block_ = false;
bool McrDebug::exp_profile_breakdown_ = false;

bool McrDebug::AnyOptionEnabled() {
  return VerifyInvokeQuick() || VerifyInvokeQuickLlvmToQuick() ||
         VerifyInvokeQuickThourghRT_SLOW() ||
         VerifyArtMethod() ||
         VerifyArtClass() ||
         VerifyArtObject() ||
         VerifyLlvmInvokeWrapper() ||
         VerifyInvokeLlvm() ||
         VerifyLlvmCalled() ||
         VerifyLoadClass() ||
         VerifySpeculation() ||
         VerifySpeculationMiss() ||
         VerifyInvokeJni() ||
         VerifyInvoke() ||
         VerifyInitInner() ||
         VerifyBasicBlock() ||
         DebugLlvmCode() ||
         DebugInvokeJni() ||
         QuickThroughRT() ||
         SuspendCheckSimplify() ||
         SkipSuspendCheck() ||
         SpeculativeDevirt() ||
         InterpretNonhot() ||
         DebugInvokeQuick();
}

void McrDebug::SetRecompilation() {
  std::ofstream output(F_LLVM_RECOMPILE);
}

bool McrDebug::ImplicitNullChecks() {
  return kFakeImplicitCheck && !McrDebug::DebugLlvmCode2();
}

void McrDebug::ClearRecompilation() {
  unlink(F_LLVM_RECOMPILE);
}

void McrDebug::ReadOptions() {
  ReadQuickThroughRT();
  ReadSuspendCheckSimplify();
  ReadSkipSuspendCheck();

  ReadDebugInvokeQuick();
  ReadDebugInvokeJni();
  ReadDebugLlvmCode();

  ReadVerifyInitInner();
  ReadVerifyBasicBlock();

  ReadVerifyArtMethod();
  ReadVerifyArtClass();
  ReadVerifyArtObject();
  ReadVerifyInvoke();
  ReadVerifyInvokeJni();
  ReadVerifyInvokeQuick();
  ReadVerifyInvokeQuickLlvmToQuick();
  ReadVerifyInvokeQuickThroughRT_SLOW();
  ReadVerifyLLvmInvokeWrapper();
  ReadVerifyInvokeLlvm();
  ReadVerifyLlvmCalled();
  ReadVerifyLoadClass();
  ReadVerifySpeculation();
  ReadVerifySpeculationMiss();
  ReadSpeculativeDevirt();
  ReadInterpretNonhot();
}

void McrDebug::ReadVerifyBasicBlock() {
  verify_basic_block_ = IsEnabled(F_VERIF_BASIC_BLOCK);
}

void McrDebug::ReadVerifyInitInner() {
  verify_init_inner_ = IsEnabled(F_VERIF_INIT_INNER);
}

void McrDebug::ReadVerifyLoadClass() {
  verify_load_class_ = IsEnabled(F_VERIF_LOAD_CLASS);
}

void McrDebug::ReadVerifySpeculation() {
  verify_speculation_ = IsEnabled(F_VERIF_SPECULATION);
}

void McrDebug::ReadVerifySpeculationMiss() {
  verify_speculation_miss_ = IsEnabled(F_VERIF_SPECULATION_MISS);
  // die_on_speculation_miss_ = verify_speculation_miss_;
}

void McrDebug::ReadSpeculativeDevirt() {
  speculative_devirt_ = !IsEnabled(F_DISABLE_SPECULATION);
}

void McrDebug::ReadInterpretNonhot() {
  interpret_nonhot_ = IsEnabled(F_INTEPRET_NONHOT);
}

void McrDebug::ReadVerifyInvoke() {
  verify_invoke_ = IsEnabled(F_VERIF_INVOKE);
}

void McrDebug::ReadQuickThroughRT() {
  std::string filename = mcr::GetFileApp(F_OPT_QUICK_THROUGH_RT);
  opt_quick_through_rt_ = IsEnabled(filename);
}

void McrDebug::ReadSuspendCheckSimplify() {
  std::string filename = mcr::GetFileApp(F_SUSPEND_CHECK_SIMPLIFY);
  sc_simplify_ = IsEnabled(filename);
}

void McrDebug::ReadSkipSuspendCheck() {
  skip_suspend_check_ = IsEnabled(F_SKIP_SUSPEND_CHECK);
}

void McrDebug::ReadDebugLlvmCode() {
  debug_llvm_code_ = IsEnabled(F_DBG_LLVM_CODE);
}

void McrDebug::ReadDebugInvokeJni() {
  debug_invoke_jni_ = IsEnabled(F_DBG_INVOKE_JNI);
}

void McrDebug::ReadVerifyInvokeJni() {
  verify_invoke_jni_ = IsEnabled(F_VERIF_INVOKE_JNI);
}

void McrDebug::ReadDebugInvokeQuick() {
  debug_invoke_quick_ = IsEnabled(F_DBG_INVOKE_QUICK);
}

void McrDebug::ReadVerifyLLvmInvokeWrapper() {
  verify_llvm_invoke_wrapper = IsEnabled(F_VERIF_LLVM_INVOKE_WRAPPER);
}

void McrDebug::ReadVerifyInvokeLlvm() {
  verify_invoke_llvm_ = IsEnabled(F_VERIF_INVOKE_LLVM);
}

void McrDebug::ReadVerifyLlvmCalled() {
  verify_llvm_called_ = IsEnabled(F_VERIF_LLVM_CALLED);
}

void McrDebug::ReadVerifyInvokeQuick() {
  verify_invoke_quick_ = IsEnabled(F_VERIF_INVOKE_QUICK);
}

void McrDebug::ReadVerifyArtMethod() {
  verify_art_method_ = IsEnabled(F_VERIF_ART_METHOD);
}

void McrDebug::ReadVerifyArtClass() {
  verify_art_class_ = IsEnabled(F_VERIF_ART_CLASS);
}

void McrDebug::ReadVerifyArtObject() {
  verify_art_obj_ = IsEnabled(F_VERIF_ART_OBJ);
}

void McrDebug::ReadVerifyInvokeQuickLlvmToQuick() {
  verify_invoke_quick_LlvmToQuick_ = IsEnabled(F_VERIF_INVOKE_QUICK_LLVM_TO_QUICK);
}

void McrDebug::ReadVerifyInvokeQuickThroughRT_SLOW() {
  verify_invoke_quick_ThroughRTslow_ = IsEnabled(F_VERIF_INVOKE_QUICK_THROUGH_RT_SLOW);
}

bool McrDebug::IsEnabled(std::string option) {
  return OS::FileExists(option.c_str());
}

bool McrDebug::QuickThroughRT() {
  return opt_quick_through_rt_;
}

bool McrDebug::SuspendCheckSimplify() {
  return sc_simplify_;
}

bool McrDebug::SkipSuspendCheck() {
  return skip_suspend_check_;
}

bool McrDebug::SpeculativeDevirt() {
  return speculative_devirt_;
}

bool McrDebug::InterpretNonhot() {
  return interpret_nonhot_;
}

bool McrDebug::DebugInvokeJni() {
  return debug_invoke_jni_;
}

bool McrDebug::DebugInvokeQuick() {
  return debug_invoke_quick_;
}

bool McrDebug::VerifyBasicBlock(std::string pretty_method) {
  // option is not overriden
  if(pretty_method.size() == 0) return verify_basic_block_;

  if(verify_basic_block_) { // enabled
    if (mcr::Analyser::HasDebugMethodsProfile()) { // there is debug profile
      const bool dbg = mcr::Analyser::IsInDebugMethodsProfile(pretty_method);
      return dbg;
    }
    return true;
  }
  return false;
}

bool McrDebug::VerifyInitInner() {
  return verify_init_inner_;
}

bool McrDebug::VerifyInvoke() {
  return verify_invoke_;
}

bool McrDebug::VerifyInvokeLlvm() {
  return verify_invoke_llvm_ || VerifyInvoke();
}

bool McrDebug::VerifyLlvmCalled() {
  return verify_llvm_called_;
}

bool McrDebug::VerifyInvokeJni() {
  return verify_invoke_jni_ || VerifyInvoke();
}

bool McrDebug::VerifyInvokeQuick() {
  return verify_invoke_quick_ || VerifyInvoke();
}

bool McrDebug::VerifyArtMethod() {
  return verify_art_method_;
}

bool McrDebug::VerifyArtClass() {
  return verify_art_class_;
}

bool McrDebug::VerifyArtObject() {
  return verify_art_obj_;
}

bool McrDebug::VerifyLlvmInvokeWrapper() {
  return verify_llvm_invoke_wrapper;
}

bool McrDebug::VerifyInvokeQuickLlvmToQuick() {
  return verify_invoke_quick_LlvmToQuick_ || VerifyInvokeQuick();
}
bool McrDebug::VerifyInvokeQuickThourghRT_SLOW() {
  return verify_invoke_quick_ThroughRTslow_ || VerifyInvokeQuick();
}

bool McrDebug::VerifyLoadClass() {
  return verify_load_class_;
}

bool McrDebug::VerifySpeculation() {
  return verify_speculation_;
}

bool McrDebug::VerifySpeculationMiss() {
  return verify_speculation_miss_ || VerifySpeculation();
}

bool McrDebug::DieOnSpeculationMiss() {
  return die_on_speculation_miss_;
}

void McrDebug::PrintOptions() {
  LogSeverity lvl = WARNING;
  bool slowDownOpt = false;
  if (AnyOptionEnabled()) {
    DLOG(lvl)
      << "+-----------------------------------\n"
      << "| DEBUG OPTIONS:";

    if (VerifyLlvmCalled()) {
      slowDownOpt = true;
      DLOG(lvl) << "| VERIFY: LLVM called";
    }

    if (VerifyArtMethod()) {
      slowDownOpt = true;
      DLOG(lvl) << "| VERIFY: ArtMethod";
    }

    if (VerifyArtClass()) {
      slowDownOpt = true;
      DLOG(lvl) << "| VERIFY: ArtClass";
    }

    if (VerifyArtObject()) {
      slowDownOpt = true;
      DLOG(lvl) << "| VERIFY: ArtObject";
    }

    // VERIFICATION OPTIONS

    std::string vinvokes="";   
    if (VerifyInvoke()) {
      vinvokes += "ALL: ";
    }

    if (VerifyInvokeLlvm()) {
      vinvokes += " LLVM";
    }

    if (VerifyInvokeJni()) {
      vinvokes += " JNI";
    }
    if (VerifyInvokeQuick()) {
      vinvokes += " QuickALL";
    }

    if (VerifyInvokeQuickThourghRT_SLOW()) {
      vinvokes += " QuickSLOW_RT";
    }

    if (VerifyInvokeQuickLlvmToQuick()) {
      vinvokes += " QuickLLVM";
    }
    if(vinvokes.size()>0) {
      slowDownOpt = true;
      DLOG(lvl) << "| VERIFY: Invoke: " << vinvokes;
    }

    if (VerifyLlvmInvokeWrapper()) {
      slowDownOpt = true;
      DLOG(lvl) << "| VERIFY: LLVM Invoke Wrapper";
    }

    if (VerifyLoadClass()) {
      slowDownOpt = true;
      DLOG(lvl) << "| VERIFY: LoadClass";
    }

    if (VerifySpeculationMiss() && !VerifySpeculation()) {
      DLOG(lvl) << "| VERIFY: Speculations: misses";
    } else if (VerifySpeculation()) {
      slowDownOpt = true;
      DLOG(lvl) << "| VERIFY: Speculations: all";
    } else {
      DLOG(ERROR) << "| WARNING: Disabled SPECULATION_MISS: keep this on!";
    }

    if (SkipSuspendCheck()) {
      DLOG(ERROR) << "| WARNING OPT: Skip suspendcheck RT call";
    }

    if (!SpeculativeDevirt()) {
      DLOG(ERROR) << "| WARNING: Disable Speculative Devirtualization!";
    }

    if (InterpretNonhot()) {
      DLOG(WARNING) << "| WARNING: Interpreting cold methods! (android10 default)";
    }

    if (SuspendCheckSimplify()) {
      DLOG(WARNING) << "| WARNING: SuspendCheck: for nested loops";
    }

    if (QuickThroughRT()) {
      DLOG(ERROR) << "| WARNING: OPT: Quick through RT (not LLVMtoQUICK)";
    }

    // DEBUG OPTIONS
    if (DebugInvokeJni()) {
      slowDownOpt = true;
      DLOG(lvl) << "| DEBUG:  InvokeJni";
    }
    if (DebugInvokeQuick()) {
      slowDownOpt = true;
      DLOG(lvl) << "| DEBUG:  InvokeQuick";
    }

    if (VerifyInitInner()) {
      slowDownOpt = true;
      DLOG(lvl) << "| VERIFY: InitInner";
    }

    if (VerifyBasicBlock()) {
      slowDownOpt = true;
      DLOG(lvl) << "| VERIFY: BasicBlock";
    }

    if (DebugLlvmCode()) {
      slowDownOpt = true;
      DLOG(lvl) << "| DEBUG LLVM CodeGeneration:";
      DLOG(lvl) << "| CHECK_LLVMD, TODO_LLVMD, etc..";
    }

    if (!ImplicitNullChecks()) {
      slowDownOpt = true;
      DLOG(lvl) << "| WARNING: SLOW NullChecks!";
    }

    if(slowDownOpt) {
      DLOG(ERROR) << "| ";
      DLOG(ERROR) << "| WARNING: Some of the options will cause SLOWDOWNS!";
    }

    DLOG(lvl) << "+-----------------------------------\n";
  }

#ifndef LLVM_TO_QUICK
      DLOG(lvl) << "NOT USING: LLVMtoQUICK";
#endif
#ifndef LLVM_TO_JNI
      DLOG(lvl) << "NOT USING: LLVMtoLJI";
#endif
}

}  // namespace art
